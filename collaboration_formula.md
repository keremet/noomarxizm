# Формула участия

Рассмотрим формально, как участие в коллеткивной разработке требуемого информационного продукта становится для компаний выгоднее покупки.

Как мы выяснили ранее, стоимость информационного продукта `V` равна сумме стоимости оригинала `C` и стоимости копирования `S`, умноженной на общее количество сделанных копий `K` (в пределе):

```
V = C + S * K
```

Тогда стоимость одной копии `Vc = V / K`


При этом цена копии `Pc` часто во много раз больше ее стоимости:

```
Vc << Pc
```

Теперь, согласно трудовой теории стоимости, издержки `I` на производство оригинала должны быть меньше его стоимости `C`. То есть, для стоимости производства `Vp` выполняется:

```
Vp = I + S * K
Vp < V
```

Если все потребители участвуют в производстве в равной мере, то их личные затраты есть

```
Vip = Vp / K + X
```

Так вот, так как

```
Vp / K < V / K
V / K = Vc
Vp / K < Vc << Pc
```

то как только коэффициент `X` снижается до такого уровня, что `Vip < Pc`, так участие в свободном производстве становится выгоднее, чем покупка готового продукта, произведенного на стороне. Сам `X` отражает дополнительные издержки на организацию широкой кооперации производителей, он обратно пропорционален уровню развития производительных сил для совместной работы в составе производящего сообщества.

Эти формулы - это достаточно высоко абстрактная и упрощенная модель. Конечно присутствуют неравномерности и отклонения, но они отчасти сами себя компенсируют. Формулы можно уточнить, добавив дополнительные коэффициенты, которые будут зависеть от разных случайностей на практике, но мы получим все то же отношение, просто появятся дополнительные уточняющие условия.

Пока что здесь показаны *идеализированные условия*, что происходит *в сущности*. В реальной жизни существует масса шероховатостей и дополнительных условий, одни из которых препятствуют, но другие — способствуют реализации данной модели. Эти отклонения еще требуют своего изучения.

Для неравномерного участия потребителей в производстве личные затраты `Vipk` есть

```
Vipk = Yk * Vp / K + Xk,
Vp = Sum(Vipk, k = 1..K)

// ...
Vp = Sum(Yk * Vp / K + Xk, k = 1..K),
Vp = Sum(Yk * Vp / K, k = 1..K) + X,
Vp = Sum(Yk, k = 1..K) * Vp / K + X,
Vp = Y * Vp / K + X,
Vp < Y * V / K + X,
Vp < Y * Vc + X,
// ...

Vipk = Yk * Vp / K + Xk,
Vipk < Yk * V / K + Xk,
Vipk < Yk * Vc + Xk, Vc << Pc

Vipk < Vc
Vipk = Yk * Vp / K + Xk < Vc
Yk * Vp / K + Xk < Vc,

Yk * Vp / K + Xk < V / K,
Yk * Vp + Xk * K < V,
```
